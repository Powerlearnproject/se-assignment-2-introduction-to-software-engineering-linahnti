1. Software engineering is the systematic application of engineering principles, methods, and tools to the development and maintenance of high
quality software systems. It involves the design, development, testing, deployment, and maintenance of software products.

2. Sotware engineering is the process of designing, developing, testing, and maintaining software. It is a systematic and disciplined approach
to software development that aims to create high-quality, reliable, and maintainable software while traditional proramming refers to the process of 
providing explicit instructions to a computer to perform a specific task. In traditional programming programmers solve problems by following a rule 
based approach.
Software Development Life Cycle: It ia a methodology that defines design, development, and testing the entire process of software development
step by step. It simply outlines the whole process of developing a software system.

3. Phases of SDLC
a. Planning - It is the first phase, it involves gathering business requirements from clients and stakeholders. It involves looking for 
an answer for the problem to be solved i.e pinpointing the software's purpose and scope.
b. Analysis - It is the process in which the development team translates high-level plans and goals into actionable ideas. It involves
organizing the colleceted requirements.
c. Design - It involves software engineers analyzing requirements and identifying the best solutions to create the software. It deciding what 
are optimising and deign for the same.
d. Implementation - Also called the coding stage, it is where the team writes the actual code for the product.
e. Testing - After the team has finished writting the code, it is ready for testing. Software tests assess how well an application meets goals in 
areas such as performance, load, security and usability. It also checks for software errors and if the product meets the requirements.
f. Deployment - Is the stage where the application moves into a production environment, where it is accessible to end users.
g. Maintenance -  It is the final phase which involves, monitoring the application on a continuous basis to identify issues that arise once
it is in production.

4. Agile vs. Waterfall
a. In waterfall, planning is a linear process done at the beginning of the project, with all requirements and objectives laid out in detail upfront
while agile planning is a continuous process throughout the project's life cycle, with adjustments made as new information or requirements emerge.
b. The waterfall methodology generally discourages changes to the project's scope  because the methodology requires an extensive amount of time 
spent in the beginning trying to get the plan right while agile is more adaptable to changes in scope, with the development team able to adjust 
quickly as requirements change.
c.  The waterfall method is designed for long-term projects with predetermined timelines while agile uses short iterations to deliver
value rapidly, allowing teams to adjust plans over time and achieve shorter time frames.
d. Waterfall projects tend to take longer because all requirements must be agreed upon before development can begin while agile projects, on the  
other hand, are usually delivered more rapidly than waterfall projects due to the iterative development cycles used in agile. 
e. Agile encourages teams to respond quickly and adaptively to changes during the development process while waterfall is less flexible and resistant 
to change once the project's scope has been defined.
f. Agile relies on minimal documentation, focusing on self-organizing teams and collaboration while waterfall relies heavily on documenting 
each step in detail to ensure that all team members are on the same page.

5. Requirements engineering:
It is the process of understanding and defining what services are required from the system and identifying the constraints on the system's operation a
and development.
The process:
i. Feasibility study - The study cosiders whether the proposed system will be cost effective from a business point of view and if it can be developed 
within existing budgetary constraints. It should be cheap and quick.
ii. Requirements elicitation and analysis - This is the process of deriving the system requirements through observation of existing systems, discussions
with potential users and producers and task analysis.
iii. Requirements specification - Is the activity of translating information gathered during the analysis acitivity into a document that defines a set of
requirements that is user and system requirements.
iv. Requirements valudation - It checks the requirements for realism, consistency and completeness. During this process, errors in the requirements document
are discovered and the document modified to correct these problems.
Importance:
a. Helps ensure that the software being developed meets the needs and expectations of the stakeholders.
b. Provides a solid foundation for the development process, which helps to reduce the risk of failure.
c. Helps to ensure that the software system is delivered on time, within budget, and to the required quality standards.
d. Helps to identify potential conflicts and contradictions in the requirements, which can be resolved before the software development process begins.
e. Can improve communication and collaboration between the development team and stakeholder.
f. Provides clear guidance on what needs to be developed. 

6. Software design principles:
Modularity in software design is a technique where complex software is divided into smaller, independent modules, such as functions, classes, or 
components. It facilitates easier management and understanding of complex systems by breaking them down into digestible parts.
a. Maintainability - Changes in one module typically do not affect others, making bugs easier to track down and fix without risking other parts 
of the system. When a change is needed, it often affects only a specific module. This isolation minimizes the risk of introducing bugs in other 
parts of the system. 
b. Scalability - Modular systems can be scaled more readily by adding new modules or enhancing existing ones without impacting the rest of the system.
Different modules can be developed in parallel by different teams, speeding up the development process.

7. Testing into Software Engineering:
o unit testing - test methods within each object 
o integration testing - test collaborations between objects 
o system testing - test the entire system as a collection of objects 
o acceptance testing - test for standards and customer satisfaction
Importance of software testing:
a. Risk Mitigation – Testing helps identify defects and failures early in the development process when they are less expensive to fix. This 
reduces project risks related to quality, security, performance, etc.
b. Confidence – Executing a well–planned software test strategy provides confidence that the software works as intended before its release.
Compliance – Testing can ensure that software adheres to standards, regulations, and compliance requirements. This is especially critical for 
safety–critical systems.
c. User Satisfaction – Rigorous testing from a user perspective can verify usability, functionality, and compatibility. This increases customer/user 
satisfaction and reduces negative impacts to an organization’s reputation or finances from poor quality products.
d. Optimization – Testing provides vital feedback that can be used to continuously improve software quality, user experience, security, performance
and other product attributes.
e. Cost Savings – Investing in testing activities reduces downstream costs related to defects found post–release. It is much cheaper to find and fix
bugs earlier in the development cycle.

8. Version Control Systems:
Version control is a system that tracks the progress of code across the software development lifecycle and its multiple iterations – which maintains a 
record of every change complete with authorship, timestamp, and other details – and also aids in managing change.
Importance:
a. Helps in recovery in case of any disaster or contingent situation.
b. Informs us about Who, What, When, Why changes have been made.
c. Enhances the project development speed by providing efficient collaboration,
d. Leverages the productivity, expedites product delivery, and skills of the employees through better communication and assistance.
e. Reduce possibilities of errors and conflicts meanwhile project development through traceability to every small change.
f. Contributors of the project can contribute from anywhere irrespective of the different geographical locations through this VCS.
Examples:
1. Helix core -  is a centralized version control system by Perforce Software. It’s the leading version control system for game developers and is also
used in media & entertainment and semiconductor design.
Features: Single Source of truth
          Limitless architecture
          Impenetrable Security
          Automated Workflows
          Complete Version history
          World-class support
2. New relic
Features: Explore data for detailed analysis
          Helpful for troubleshooting and optimization
          Custom alerting capabilities for staying informed about issues.
3. AWS CodeCommit
Features: Default allowance of up to a thousand repositories and AWS CodeCommit
          Option to store and version any type of file.
          Ability to create up to 25,000 additional repositories upon requests.
          Outstanding alerting system for notifications on repository-related events.
4. Git - distributed control system for developers.
Features: Affordable local branching
          Convenient staging areas
          Ability to create multiple independent local branches
          Enables seamless context-switching
          Supports role-based code lines
          Facilitates feature-based workflow
5. Subversion
Features: Interactive conflict resolution
          Atomic commits
          Cheap branching and tagging

9. Software project Management
Software maintenance is the process of changing, modifying, and updating software to keep up with customer needs.
Types:
a. Corrective Maintenance -  this type of software maintenance is carried out to correct bugs and other such 
problems that are usually reported by users or arrived at by studying error reports.
b. Adaptive Maintenance: This includes all such updates and modifications that are required to keep the software
product up-to-date so that it adapts well with the ever-changing technological world.
c. Perfective Maintenance: This type of software maintenance is carried out to keep the software functionable for
a long time. It includes modification to include new features and requirements to make the software more reliable.
d. Preventive Maintenance: Preventive maintenance is carried out to prevent any future problems that may arise in 
the functioning of the software. It attends problems that have not specifically caused any problem at the present 
but may cause issues in near future.
Importance:
Correct errors.
Change in user requirement with time
Changing hardware/software requirements.
To improve system efficiency.
To optimize the code to run faster.
To modify the components.
To reduce any unwanted side effects.
Adapts to Changing Environments.
Extends Software Lifespan.

10. Ethical considerations in software engineering
a. Algorithmic bias -  Creating algorithms that are fair and unbiased, avoiding discrimination. For example Google 
was recently criticized for perpetuating systemic racism when it was discovered that their image processing technology
couldn’t accurately represent black and brown skin tones in photos.
b. Personal data collection - major ethical dilemma in software engineering is how data is collected and managed.Many
businesses generate revenues by sharing user data unethically.
c. Weak security protection - Hackers can cause lasting damage to real people and companies. Software engineers should 
address security during development and after code release, rather than focusing strictly on getting the product to market.
d. Transparency and Accountability -  Being transparent about the capabilities and limitations of software, and taking
responsibility for its impact.
How to adhere:
Practice Responsible Software Release -  Prioritize fixing critical bugs and addressing security vulnerabilities before deployment.
Report and Address Ethical Violations - Take reported concerns seriously and investigate promptly, implementing corrective measures
as needed.
Maintain Transparency with Stakeholders -  Provide detailed documentation and disclosures about the software’s functionality and 
decision-making processes.
Ensure Fairness and Avoid Bias - Use diverse data sets and conduct fairness assessments regularly.
Implement Strong Data Protection Measures - Ensure robust data encryption, access controls, and regular security audits.













































































